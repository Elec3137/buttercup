#!/usr/bin/env fish
# btrfs backup - butter cup :3

function print_usage
    printf 'usage: --origin-path <subvol> [--backup-path <mount>]

origin-path must be given, and must be a subvolume
\tIf it doesn\'t contain a ".snapshots" child subvolume, one will be created

If backup-path is given, then the program will run an automatically-managed incremental backup to that location
\tOtherwise, it will simply prompt to cycle snapshots within origin
'
    exit
end

function err --description 'prints the given error message and exits'
    set_color brred >&2
    printf "%s\n" "$argv" >&2
    set_color normal >&2
    exit 1
end

function info --description 'prints info as cyan into stderr, to enhance readability and avoid being hidden and used by redirection'
    set_color cyan >&2
    printf "%s\n" "$argv" >&2
    set_color normal >&2
end

function assertArgNumber --description 'prints warning messages and exits if the calling function has a different number of args than specified' --argument-names real expected function
    if test "$real" -lt "$expected"
        err "less than expected $expected arguments to $function"
    else if test "$real" -gt "$expected"
        err "extraneous argument(s) to $function"
    end
end

function isSubv --description 'check if the given dir is a subvolume' --argument-names dir
    assertArgNumber (count $argv) 1 (status function)

    if path is -d "$dir"
        and test $(stat --format=%i "$dir") -eq 256
        return 0
    else
        return 1
    end
end

function getCreationTime --description 'outputs the creation time of the given subvolume' --argument-names subvol
    assertArgNumber (count $argv) 1 (status function)

    echo "$(date --date $(sudo btrfs subvolume show "$subvol" | grep -oP 'Creation time:\s*\K\d.*$') +%s)"
end

function listSubv --description 'lists subvolumes in the given path' --argument-names path
    assertArgNumber (count $argv) 1 (status function)

    for i in (find "$path" -maxdepth 1 -mindepth 1)
        if isSubv "$i"
            printf "%s\n" "$i"
        end
    end
end

function listSubvTime --description 'lists subvolumes in the given path with their creation date in seconds first, so they can then be sorted' --argument-names path
    assertArgNumber (count $argv) 1 (status function)

    for i in (find "$path" -maxdepth 1 -mindepth 1)
        if isSubv "$i"
            # please include options for machine readable output so this would not be needed
            printf "%s %s\n" "$(getCreationTime "$i")" "$i"
        end
    end
end

function listSubvSort --description 'wraps listSubvTime, sorts it, and removes the time' --argument-names path
    assertArgNumber (count $argv) 1 (status function)

    listSubvTime "$path" | sort -n | cut -d' ' -f2-
end

function mostRecentSubv --argument-names path
    set sortedSubvols $(listSubvSort "$path")
    echo $sortedSubvols[-1]
end

function leastRecentSubv --argument-names path
    set sortedSubvols $(listSubvSort "$path")
    echo $sortedSubvols[1]
end

function takeSnapshot --description 'takes a ".snapshots" subvolume and snapshots the parent into it with a random int name' --argument-names source
    assertArgNumber (count $argv) 1 (status function)

    sudo btrfs subvolume snapshot -r "$(path normalize "$source/../")" "$source/$(random)"
end

function renameReceived --description 'after snapshot is received, this would be called to rename it with the creation time of the original subvolume to keep track of its parent' --argument-names subvol mount
    assertArgNumber (count $argv) 2 (status function)

    sudo mv -v "$mount/$(path basename "$subvol")" "$mount/$(getCreationTime "$subvol")"
end

function markParent --argument-names subvol
    mv "$subvol" ""$subvol"parent"
end

function unmarkParent --argument-names subvol
    mv "$subvol" "$(path dirname "$subvol")/$(path basename "$subvol" | cut -d'p' -f 1)"
end

function initialBackup --description 'used for the first backup, before incremental backups are possible' --argument-names source mount
    assertArgNumber (count $argv) 2 (status function)

    set subvol (mostRecentSubv "$source")
    info "sending initial backup of '$subvol' and receiving at '$mount'"
    info "this tends to take a while; it will simply copy all the data"
    sudo btrfs send --compressed-data "$subvol" | sudo btrfs receive "$mount"
    renameReceived "$subvol" "$mount"
    markParent "$subvol"
end

function getParent --description 'outputs the correct parent for the next incremental backup' --argument-names source mount
    assertArgNumber (count $argv) 2 (status function)

    set sourceSnaps $(listSubvTime "$source")
    set latestIncrement $(mostRecentSubv "$mount")
    for i in $sourceSnaps
        if test (echo $i | cut -d' ' -f1) -eq "$(path basename "$latestIncrement")"
            echo $i | cut -d' ' -f2-
            return 0
        end
    end

    err "parent subvolume for latestIncrement '$latestIncrement' seems to be missing"
end

function incrementalBackup --description 'the primary function; a sort of "wrapper" for btrfs send and receive with the parent specified' --argument-names source mount
    assertArgNumber (count $argv) 2 (status function)

    set parent (getParent "$source" "$mount")
    set subvol (mostRecentSubv "$source")
    if test "$parent" = "$subvol"
        info "no subvolumes more recent than '$parent' to backup; taking a new snapshot"
        takeSnapshot "$source"
        set subvol (mostRecentSubv "$source")
        if test "$parent" = "$subvol"
            err "failed to create a newer snapshot"
        end
    end
    info "sending incremental backup with the difference between '$subvol' and '$parent' and receiving at '$mount'"
    sudo btrfs send --compressed-data "$subvol" -p "$parent" | sudo btrfs receive "$mount"
    renameReceived "$subvol" "$mount"
    unmarkParent "$parent"
    markParent "$subvol"
    minimizeSnapshotsAfterIncrement "$source"
end

function minimizeSnapshotsAfterIncrement --description 'reduces the snapshots on the source to just the neccessary "parent" plus one extra.
This is to avoid  the user manually deleting snapshots to save space, and potentially deleting the parent which breaks the chain of incremental backups
The newParent arg is there as an additional safeguard to avoid deleting that important subvolume' --argument-names source
    assertArgNumber (count $argv) 1 (status function)

    info "post-increment regulating snapshots in '$source'"
    while test (count (listSubv "$source")) -gt 2
        set deletionTarget (leastRecentSubv "$source")
        if test "$deletionTarget" = "$source"
            err "deletionTarget is equivelent to source '$deletionTarget'"
        else if string match -qv '*parent*' "$deletionTarget"
            info "skipping deletion of '$deletionTarget' as it is marked as a parent"
            info "    you may manually delete it if unneeded with 'btrfs subvolume delete \"$deletionTarget\"'"
            info "  skipping snapshot cleanup due to oldest remaining snapshot being a parent"
            break
        else
            sudo btrfs subvolume delete "$deletionTarget"
        end

    end

end

function regulateSnapshots --argument-names source
    assertArgNumber (count $argv) 1 (status function)

    info "regulating snapshots in '$source'"
    if test (count (listSubv "$source")) -gt 2
        set deletionTarget (leastRecentSubv "$source")
        if test "$deletionTarget" = "$source"
            err "deletionTarget is equivelent to source '$deletionTarget'"
        else if string match -qv '*parent*' "$deletionTarget"
            info "skipping deletion of '$deletionTarget' as it is marked as a parent"
            info "    you may manually delete it if unneeded with 'btrfs subvolume delete \"$deletionTarget\"'"
            info "  skipping snapshot cleanup due to oldest remaining snapshot being a parent"
        else
            sudo btrfs subvolume delete "$deletionTarget"
        end
    end

    takeSnapshot "$source"
end

argparse h/help 'o/origin-path=' 'b/backup-path=' -- $argv
or print_usage

if set -ql _flag_h
    print_usage
end

# origin must always be defined and valid
if not isSubv "$_flag_o"
    # TODO: add option and functions to convert to a subvolume upon request
    err "origin-path must be set to a subvolume"
end

# make sure origin is ready for snapshots
if not isSubv "$_flag_o/.snapshots" # TODO: account for case in which it is not a subvolume, and contains files
    sudo btrfs subvolume create "$_flag_o/.snapshots"
    or err "unable to stage source"
end
if test (count (listSubv "$_flag_o/.snapshots")) -lt 1
    takeSnapshot "$_flag_o"
    and set snapshotShift
    or err "unable to create initial snapshot"

end

if set -ql _flag_b
    if not path is -d "$_flag_b"
        err "backup-path must be set to a directory"
    end

    if test (count (listSubv "$_flag_b")) -eq 0
        initialBackup "$_flag_o/.snapshots" "$_flag_b"
    else
        incrementalBackup "$_flag_o/.snapshots" "$_flag_b"
        and set snapshotShift
    end

else
    regulateSnapshots "$_flag_o/.snapshots"
    and set snapshotShift
end

# update list within grub with mkconfig
# if snapshotShift wasn't recorded, origin was not root, or grub-btrfs wasn't found, fail silently
if set -q snapshotShift
    and test "$(path normalize $_flag_o)" = /
    and pacman -Q grub-btrfs >/dev/null

    info "grub-btrfs detected, updating grub to populate snapshot entries"
    sudo grub-mkconfig -o /boot/grub/grub.cfg
end
