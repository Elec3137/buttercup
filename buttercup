#!/usr/bin/env fish
# btrfs backup - butter cup :3

function print_usage
    printf 'usage: --origin-path <subvol> [--backup-path <mount>]

origin-path must be given, and must be a subvolume
\tIf it doesn\'t contain a ".snapshots" child subvolume, one will be created

If backup-path is given, then the program will run an automatically-managed incremental backup to that location
\tOtherwise, it will simply prompt to cycle snapshots within origin
'
    exit
end

function err -d 'prints the given error message and exits'
    set_color brred >&2
    printf "%s\n" "$argv" >&2
    set_color normal >&2
    exit 1
end

function info -d 'prints info as cyan into stderr, to enhance readability and avoid being hidden and used by redirection'
    set_color cyan >&2
    printf "%s\n" "$argv" >&2
    set_color normal >&2
end

function assertArgNumber -d 'prints warning messages and exits if the calling function has a different number of args than specified' -a real expected function
    if test "$real" -lt "$expected"
        err "less than expected $expected arguments to $function"
    else if test "$real" -gt "$expected"
        err "extraneous argument(s) to $function"
    end
end

function isSubv -d 'check if the given dir is a subvolume' -a dir
    assertArgNumber (count $argv) 1 (status function)

    if path is -d "$dir"
        and test $(stat --format=%i "$dir") -eq 256
        return 0
    else
        return 1
    end
end

function getCreationTime -d 'outputs the creation time of the given subvolume' -a subvol
    assertArgNumber (count $argv) 1 (status function)

    echo "$(date --date $(sudo btrfs subvolume show "$subvol" | grep -oP 'Creation time:\s*\K\d.*$') +%s)"
end

function listSubv -d 'lists subvolumes in the given path' -a path
    assertArgNumber (count $argv) 1 (status function)

    for i in (find "$path" -maxdepth 1 -mindepth 1)
        if isSubv "$i"
            printf "%s\n" "$i"
        end
    end
end

function listSubvTime -d 'lists subvolumes in the given path with their creation date in seconds first, so they can then be sorted' -a path
    assertArgNumber (count $argv) 1 (status function)

    for i in (find "$path" -maxdepth 1 -mindepth 1)
        if isSubv "$i"
            # please include options for machine readable output so this would not be needed
            printf "%s %s\n" "$(getCreationTime "$i")" "$i"
        end
    end
end

function listSubvSort -d 'wraps listSubvTime, sorts it, and removes the time' -a path
    assertArgNumber (count $argv) 1 (status function)

    listSubvTime "$path" | sort -n | cut -d' ' -f2-
end

function mostRecentSubv -a path
    set sortedSubvols $(listSubvSort "$path")
    echo $sortedSubvols[-1]
end

function oldestSubv -a path
    set sortedSubvols $(listSubvSort "$path")
    echo $sortedSubvols[1]
end

function takeSnapshot -d 'takes a ".snapshots" subvolume and snapshots the parent into it with a random int name' -a source
    assertArgNumber (count $argv) 1 (status function)

    sudo btrfs subvolume snapshot -r "$(path normalize "$source/../")" "$source/$(random)"
end

function renameReceived -d 'after snapshot is received, this would be called to rename it with the creation time of the original subvolume to keep track of its parent' -a subvol mount
    assertArgNumber (count $argv) 2 (status function)

    sudo mv -v "$mount/$(path basename "$subvol")" "$mount/$(getCreationTime "$subvol")"
end

function markParent -a subvol
    if not string match -q '*parent*' "$(path basename "$subvol")"
        info "marking new parent"
        sudo mv -v "$subvol" ""$subvol"parent"
    else
        info "subvolume '$subvol' was already marked"
    end
end

function unmarkParent -a subvol
    if string match -q '*parent*' "$(path basename "$subvol")"
        info "unmarking previous parent"
        sudo mv -v "$subvol" "$(path dirname "$subvol")/$(path basename "$subvol" | string replace 'parent' '')"
    else
        info "subvolume '$subvol' was not marked"
    end
end

function initialBackup -d 'used for the first backup, before incremental backups are possible' -a source mount
    assertArgNumber (count $argv) 2 (status function)

    if test (count (listSubv "$source")) -lt 1
        info "taking snapshot; less than 1 subvolumes in source '$source'"
        if not takeSnapshot "$source"
            err "unable to take initial snapshot"
        end
    end

    set subvol (mostRecentSubv "$source")
    info "sending initial backup of '$subvol' and receiving at '$mount'"
    info "this tends to take a while; it will simply copy all the data"
    sudo btrfs send --compressed-data "$subvol" | sudo btrfs receive "$mount"
    renameReceived "$subvol" "$mount"
    markParent "$subvol"
end

function getParent -d 'outputs the correct parent for the next incremental backup' -a source mount
    assertArgNumber (count $argv) 2 (status function)

    set sourceSnaps $(listSubvTime "$source")
    set latestIncrement $(mostRecentSubv "$mount")
    for i in $sourceSnaps
        if test (echo $i | cut -d' ' -f1) -eq "$(path basename "$latestIncrement")"
            echo $i | cut -d' ' -f2-
            return 0
        end
    end

    err "parent subvolume for latestIncrement '$latestIncrement' seems to be missing"
end

function incrementalBackup -d 'the primary function; a sort of "wrapper" for btrfs send and receive with the parent specified' -a source mount
    assertArgNumber (count $argv) 2 (status function)

    set parent (getParent "$source" "$mount")
    set subvol (mostRecentSubv "$source")
    if test "$parent" = "$subvol"
        info "no subvolumes more recent than '$parent' to backup; taking a new snapshot"
        takeSnapshot "$source"
        set subvol (mostRecentSubv "$source")
        if test "$parent" = "$subvol"
            err "failed to create a newer snapshot"
        end
    end
    info "sending incremental backup with the difference between '$subvol' and '$parent' and receiving at '$mount'"
    sudo btrfs send --compressed-data "$subvol" -p "$parent" | sudo btrfs receive "$mount"
    renameReceived "$subvol" "$mount"
    unmarkParent "$parent"
    markParent "$subvol"
    regulateSnapshots "$source" 2
end

function delOldestSubv -d 'deletes the oldest subvolume; if its name is not marked as a parent' -a source
    assertArgNumber (count $argv) 1 (status function)

    set deletionTarget (oldestSubv "$source")
    if test "$deletionTarget" = "$source"
        err "deletionTarget is equivelent to source '$deletionTarget'"
    else if string match -q '*parent*' "$(path basename "$deletionTarget")"
        info "skipping deletion of '$deletionTarget' as it is marked as a parent"
        info "    you may manually delete it if unneeded with 'btrfs subvolume delete \"$deletionTarget\"'"
        info "  skipping snapshot cleanup due to oldest remaining snapshot being a parent"
        return 1
    else
        sudo btrfs subvolume delete "$deletionTarget"
    end
end

function regulateSnapshots -d 'trims down the number of snapshots in source to the given value' -a source numSnapshots
    assertArgNumber (count $argv) 2 (status function)

    info "regulating snapshots in '$source'"
    while test (count (listSubv "$source")) -gt "$numSnapshots"
        if not delOldestSubv "$source"
            break
        end
    end

end

argparse h/help 'o/origin-path=' 'b/backup-path=' -- $argv
or print_usage

if set -ql _flag_h
    print_usage
end

# origin must always be defined and valid
if not isSubv "$_flag_o"
    # TODO: add option and functions to convert to a subvolume upon request
    err "origin-path must be set to a subvolume"
end

# make sure origin is ready for snapshots
if not isSubv "$_flag_o/.snapshots" # TODO: account for case in which it is not a subvolume, and contains files
    sudo btrfs subvolume create "$_flag_o/.snapshots"
    or err "unable to stage source"
end

if set -ql _flag_b
    if not path is -d "$_flag_b"
        err "backup-path must be set to a directory"
    end

    if test (count (listSubv "$_flag_b")) -eq 0
        initialBackup "$_flag_o/.snapshots" "$_flag_b"
    else
        incrementalBackup "$_flag_o/.snapshots" "$_flag_b"
    end

else
    regulateSnapshots "$_flag_o/.snapshots" 3
    and takeSnapshot "$_flag_o/.snapshots"
end
