#!/usr/bin/env fish
# btrfs backup - butter cup :3

function print_usage
    printf 'usage: --origin-path <subvol> [--backup-path <mount>]

origin-path must be given, and must be a subvolume
\tIf it doesn\'t contain a ".snapshots" child subvolume, one will be created

If backup-path is given, then the program will run an automatically-managed incremental backup to that location
\tOtherwise, it will simply prompt to cycle snapshots within origin
'
    exit
end

function err --description 'prints the given error message and exits'
    set_color brred >&2
    printf "%s\n" "$argv" >&2
    set_color normal >&2
    exit 1
end

function info --description 'prints info as cyan into stderr, to enhance readability and avoid being hidden and used by redirection'
    set_color cyan >&2
    printf "%s\n" "$argv" >&2
    set_color normal >&2
end

function confirm --description 'asks for user input, returns 0 (yes) or 1 (no).'
    if not status is-interactive-read
        return 0
    end

    set_color brcyan >&2
    printf "%s [y/N]\n" "$argv" >&2
    set_color normal >&2

    read response
    if string match -qr 'y|ye|yes' $(string lower "$response")
        return 0
    else
        return 1
    end
end

function assertArgNumber --description 'prints warning messages and exits if the calling function has a different number of args than specified' --argument-names real expected function
    if test "$real" -lt "$expected"
        err "less than expected $expected arguments to $function"
    else if test "$real" -gt "$expected"
        err "extraneous argument(s) to $function"
    end
end

function isSubv --description 'check if the given dir is a subvolume' --argument-names dir
    assertArgNumber (count $argv) 1 (status function)

    if path is -d "$dir"
        and test $(stat --format=%i "$dir") -eq 256
        return 0
    else
        return 1
    end
end

function getCreationTime --description 'outputs the creation time of the given subvolume' --argument-names subvol
    assertArgNumber (count $argv) 1 (status function)

    echo "$(date --date $(sudo btrfs subvolume show "$subvol" | grep -oP 'Creation time:\s*\K\d.*$') +%s)"
end

function listSubv --description 'lists subvolumes in the given path' --argument-names path
    assertArgNumber (count $argv) 1 (status function)

    for i in (find "$path" -maxdepth 1 -mindepth 1)
        if isSubv "$i"
            printf "%s\n" "$i"
        end
    end
end

function listSubvTime --description 'lists subvolumes in the given path with their creation date in seconds first, so they can then be sorted' --argument-names path
    assertArgNumber (count $argv) 1 (status function)

    for i in (find "$path" -maxdepth 1 -mindepth 1)
        if isSubv "$i"
            # please include options for machine readable output so this would not be needed
            printf "%s %s\n" "$(getCreationTime "$i")" "$i"
        end
    end
end

function listSubvSort --description 'wraps listSubvTime, sorts it, and removes the time' --argument-names path
    assertArgNumber (count $argv) 1 (status function)

    listSubvTime "$path" | sort -n | cut -d' ' -f2-
end

function mostRecentSubv --argument-names path
    set sortedSubvols $(listSubvSort "$path")
    echo $sortedSubvols[-1]
end

function leastRecentSubv --argument-names path
    set sortedSubvols $(listSubvSort "$path")
    echo $sortedSubvols[1]
end

function takeSnapshot --description 'takes a ".snapshots" subvolume and snapshots the parent into it with a random int name' --argument-names source
    assertArgNumber (count $argv) 1 (status function)

    sudo btrfs subvolume snapshot -r "$(path normalize "$source/../")" "$source/$(random)"
end

function renameReceived --description 'after snapshot is received, this would be called to rename it with the creation time of the original subvolume to keep track of its parent' --argument-names subvol mount
    assertArgNumber (count $argv) 2 (status function)

    sudo mv -v "$mount/$(path basename "$subvol")" "$mount/$(getCreationTime "$subvol")"
end

function initialBackup --description 'used for the first backup, before incremental backups are possible' --argument-names source mount
    assertArgNumber (count $argv) 2 (status function)

    set subvol (mostRecentSubv "$source")
    sudo btrfs send --compressed-data "$subvol" | sudo btrfs receive "$mount"
    renameReceived "$subvol" "$mount"
end

function getParent --description 'outputs the correct parent for the next incremental backup' --argument-names source mount
    assertArgNumber (count $argv) 2 (status function)

    set sourceSnaps $(listSubvTime "$source")
    set latestIncrement $(mostRecentSubv "$mount")
    for i in $sourceSnaps
        if test (echo $i | cut -d' ' -f1) -eq "$(path basename "$latestIncrement")"
            echo $i | cut -d' ' -f2-
            return 0
        end
    end

    err "parent subvolume for latestIncrement '$latestIncrement' seems to be missing"
end

function incrementalBackup --description 'the primary function; a sort of "wrapper" for btrfs send and receive with the parent specified' --argument-names source mount
    assertArgNumber (count $argv) 2 (status function)

    set parent (getParent "$source" "$mount")
    set subvol (mostRecentSubv "$source")
    if test "$parent" = "$subvol"
        info "no subvolumes more recent than '$parent' to backup; taking a new snapshot"
        takeSnapshot "$source"
        set subvol (mostRecentSubv "$source")
        if test "$parent" = "$subvol"
            err "failed to create a newer snapshot"
        end
    end
    info "sending incremental backup with the difference between '$subvol' and '$parent' and receiving at '$mount'"
    sudo btrfs send --compressed-data "$subvol" -p "$parent" | sudo btrfs receive "$mount"
    renameReceived "$subvol" "$mount"
end

function regulateSnapshots --argument-names source
    assertArgNumber (count $argv) 1 (status function)

    info "regulating snapshots after successful incremental backup"
    if test (count (listSubv "$source") -gt 4)
        set deletionTarget (leastRecentSubv "$source")
        if not test "$deletionTarget" = "$source"
            sudo btrfs subvolume delete "$deletionTarget"
        else
            err "deletionTarget is equivelent to source"
        end
    end

    takeSnapshot "$source"
end

argparse h/help 'o/origin-path=' 'b/backup-path=' -- $argv
or print_usage

if set -ql _flag_h
    print_usage
end

# origin must always be defined and valid
if not isSubv "$_flag_o"
    # TODO: add option and functions to convert to a subvolume upon request
    err "origin-path must be set to a subvolume"
end

# make sure origin is ready for snapshots
if not isSubv "$_flag_o/.snapshots" # TODO: account for case in which it is not a subvolume, and contains files
    sudo btrfs subvolume create "$_flag_o/.snapshots"
    or err "unable to stage source"
end
if test (count (listSubv "$_flag_o/.snapshots")) -lt 1
    takeSnapshot "$_flag_o"
    or err "unable to create initial snapshot"

    set snapshotShift
end

if set -ql _flag_b
    if not path is -d "$_flag_b"
        err "backup-path must be set to a directory"
    end

    if test (count (listSubv "$_flag_b")) -eq 0
        initialBackup "$_flag_o/.snapshots" "$_flag_b"
    else
        if incrementalBackup "$_flag_o/.snapshots" "$_flag_b"
            # since the new parent has been assigned, it is safe to manage snapshots
            regulateSnapshots "$_flag_o/.snapshots"
            and set snapshotShift
        end
    end

else
    if confirm "cycle snapshots?"
        regulateSnapshots "$_flag_o/.snapshots"
        and set snapshotShift
    end
end

# update list within grub with mkconfig
# if snapshotShift wasn't recorded, origin was not root, or grub-btrfs wasn't found, fail silently
if set -q snapshotShift
    and test "$(path normalize $_flag_o)" = /
    and pacman -Q grub-btrfs >/dev/null

    info "grub-btrfs detected, updating grub to populate snapshot entries"
    sudo grub-mkconfig -o /boot/grub/grub.cfg
end
